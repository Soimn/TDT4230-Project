#version 450 core

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D backbuffer;
layout(rgba32f, binding = 1) uniform image2D accumulated_frames_buffer;

layout(location = 0) uniform uint frame_index;
layout(location = 1) uniform float fov;
layout(location = 2) uniform vec2 backbuffer_dim;

int random_01_counter = 0;
float
Random01()
{
	random_01_counter += 42;
	return fract(177013*sin((random_01_counter*256 + frame_index)*215600));
}

struct Sphere
{
	vec3 pos;
	float radius;
	vec3 color;
	vec3 emission;
};

float box_height = 20;
float box_width  = 20;
float box_depth  = 60;

Sphere spheres[] = Sphere[](
	Sphere(
		vec3(0, 10000 + box_height/2, box_depth/2),
		10000,
		vec3(1, 1, 1),
		vec3(0)
	),
	Sphere(
		vec3(0, -10000 - box_height/2, box_depth/2),
		10000,
		vec3(1, 1, 1),
		vec3(0)
	),
	Sphere(
		vec3(10000 + box_width/2, 0, box_depth/2),
		10000,
		vec3(1, 0, 0),
		vec3(0)
	),
	Sphere(
		vec3(-10000 - box_width/2, 0, box_depth/2),
		10000,
		vec3(0, 1, 0),
		vec3(0)
	),
	Sphere(
		vec3(0, 0, 10000 + box_depth/2),
		10000,
		vec3(1, 1, 1),
		vec3(0)
	),
	Sphere(
		vec3(0, 0, -10000 - box_depth/2),
		10000,
		vec3(1, 1, 1),
		vec3(0)
	),
	Sphere(
		vec3(box_width/2 - 4.1, -box_height/2 + 4, box_depth/2 - 4.1),
		4,
		vec3(1, 1, 1),
		vec3(0)
	),
	Sphere(
		vec3(-box_width/2 + 4.1, -box_height/2 + 4, box_depth/2 - 4*3.1),
		4,
		vec3(1, 1, 1),
		vec3(0)
	),
	Sphere(
		vec3(0, box_height/2-0.5, box_depth/4),
		0.5,
		vec3(1, 1, 1),
		vec3(1, 1, 1)
	)
);

struct HitData
{
	vec3 point;
	vec3 normal;
	int object_index;
};

HitData
CastRay(vec3 origin, vec3 ray, int ignore_index)
{
	HitData result = HitData(vec3(0), vec3(0), -1);

	float inf = 1000000;
	float closest_t = inf;
	for (int i = 0; i < spheres.length(); ++i)
	{
		if (i == ignore_index) continue;

		vec3 p = -spheres[i].pos;
		float r = spheres[i].radius;

		float b = dot(p, ray);
		float discriminant = b*b - dot(p, p) + r*r;

		float t = -b - sqrt(discriminant);
		if (discriminant >= 0 && t > 0 && t < closest_t)
		{
			closest_t = t;
			result.object_index = i;
			result.point        = ray*t;
			result.normal       = normalize(result.point - spheres[i].pos);
		}
	}

	return result;
}

void
main()
{
	if (gl_GlobalInvocationID.x < backbuffer_dim.x && gl_GlobalInvocationID.y < backbuffer_dim.y)
	{
		float screen_width  = 1.0;
		float screen_height = 9.0/16.0;
		float near_plane    = 1.0/(2.0*tan(fov/2.0));

		float screen_dx = screen_width  / (gl_NumWorkGroups.x*gl_WorkGroupSize.x);
		float screen_dy = screen_height / (gl_NumWorkGroups.y*gl_WorkGroupSize.y);

		vec3 ray = vec3(screen_width/2 - screen_dx*float(gl_GlobalInvocationID.x), -screen_height/2 + screen_dy*float(gl_GlobalInvocationID.y), near_plane);
		ray += vec3(screen_dx*Random01(), screen_dy*Random01(), 0);
		ray = normalize(ray);

		vec3 color = vec3(0);

		HitData hit = CastRay(vec3(0), ray, -1);
		if (hit.object_index != -1)
		{
			vec3 to_light = normalize(spheres[8].pos - hit.point);

			color = spheres[hit.object_index].color * max(vec3(0), dot(hit.normal, to_light));
		}

		vec3 accumulated_color = imageLoad(accumulated_frames_buffer, ivec2(gl_GlobalInvocationID.xy)).xyz + color;
		imageStore(accumulated_frames_buffer, ivec2(gl_GlobalInvocationID.xy), vec4(accumulated_color, 1));	

		imageStore(backbuffer, ivec2(gl_GlobalInvocationID.xy), vec4(accumulated_color/float(frame_index + 1), 1.0));
	}
}
