#version 450 core

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D backbuffer;
layout(rgba32f, binding = 1) uniform image2D accumulated_frames_buffer;

layout(location = 0) uniform uint frame_index;
layout(location = 1) uniform float fov;
layout(location = 2) uniform vec2 backbuffer_dim;

#define PI32  3.1415926535
#define TAU32 6.2831853071
#define PI32_ON_2 1.5707963267

struct pcg32_state
{
	uint state;
	uint increment;
};

void pcg32_seed(inout pcg32_state pcg_state, uint seed, uint increment);
uint pcg32_next(inout pcg32_state pcg_state);

pcg32_state pcg_state;

float
Random01()
{
	return pcg32_next(pcg_state) * 2.3283064365386962890625e-10;
}

// NOTE: pdf = 1/4pi
vec3
RandomDir()
{
	float x_1 = Random01();
	float x_2 = Random01();

	float phi = TAU32*x_1;
	//float theta = PI32*x_2;
	float theta = acos(1 - 2*x_2); // NOTE: inverse transform sampling: https://corysimon.github.io/articles/uniformdistn-on-sphere/

	return vec3(cos(phi)*sin(theta), sin(phi)*sin(theta), cos(theta));
}

// NOTE: pdf = 1/2pi
vec3
RandomDirInHemi(vec3 plane_normal)
{
	vec3 dir = RandomDir();
	return (dot(dir, plane_normal) < 0 ? -dir : dir);
}

void
main()
{
	uint invocation_index = gl_GlobalInvocationID.y*gl_NumWorkGroups.x*gl_WorkGroupSize.x + gl_GlobalInvocationID.x;
	uint seed = (invocation_index + frame_index*187272781)*178525871;
	pcg32_seed(pcg_state, seed, invocation_index);

	if (gl_GlobalInvocationID.x < backbuffer_dim.x && gl_GlobalInvocationID.y < backbuffer_dim.y)
	{
		uint x = gl_WorkGroupID.x*gl_WorkGroupSize.x + frame_index % gl_WorkGroupSize.x;
		uint y = gl_WorkGroupID.y*gl_WorkGroupSize.y + (frame_index / gl_WorkGroupSize.x) % gl_WorkGroupSize.y;
		imageStore(backbuffer, ivec2(x, y), vec4(vec3(Random01()), 1));
	}
}
