#version 450 core

struct Triangle
{
	vec4 alpha;
	vec4 beta;
	vec4 gamma;
};

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
layout(rgba32f, binding = 0) restrict writeonly uniform image2D backbuffer;
layout(rgba32f, binding = 1) restrict uniform image2D accumulated_frames_buffer;
layout(std140, binding = 2) restrict readonly buffer triangle_buffer {
	Triangle tris[];
};

layout(location = 0) uniform uint frame_index;
layout(location = 1) uniform float fov;
layout(location = 2) uniform vec2 backbuffer_dim;

#define PI32  3.1415926535
#define TAU32 6.2831853071
#define PI32_ON_2 1.5707963267

struct pcg32_state
{
	uint state;
	uint increment;
};

void pcg32_seed(inout pcg32_state pcg_state, uint seed, uint increment);
uint pcg32_next(inout pcg32_state pcg_state);

pcg32_state pcg_state;

float
Random01()
{
	return pcg32_next(pcg_state) * 2.3283064365386962890625e-10;
}

// NOTE: pdf = 1/4pi
vec3
RandomDir()
{
	float x_1 = Random01();
	float x_2 = Random01();

	float phi = TAU32*x_1;
	//float theta = PI32*x_2;
	float theta = acos(1 - 2*x_2); // NOTE: inverse transform sampling: https://corysimon.github.io/articles/uniformdistn-on-sphere/

	return vec3(cos(phi)*sin(theta), sin(phi)*sin(theta), cos(theta));
}

// NOTE: pdf = 1/2pi
vec3
RandomDirInHemi(vec3 plane_normal)
{
	vec3 dir = RandomDir();
	return (dot(dir, plane_normal) < 0 ? -dir : dir);
}

struct Hit_Data
{
	vec3 point;
	vec2 uv;
	float t;
};

// Derived from math presented in the paper "Fast, Minimum Storage Ray/Triangle Intersection" by MÃ¶ller and Trumbore.
// https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf
bool
MollerTrumbore(vec3 origin, vec3 ray, vec3 p0, vec3 p1, vec3 p2, bool invert_faces, out vec3 tuv)
{
	vec3 D = ray;
	vec3 T = origin - p0;
	vec3 E_1 = p1 - p0;
	vec3 E_2 = p2 - p0;
	vec3 E_1xE_2 = cross(E_1, E_2);
	vec3 DxT     = cross(D, T);

	float denominator = dot(-D, E_1xE_2);

	tuv = vec3(dot(T, E_1xE_2), dot(-E_2, DxT), dot(E_1, DxT)) / denominator;

	bool hit_plane = (invert_faces ? denominator > 0 : denominator < 0);
	return (hit_plane && tuv.x > 0 && tuv.y >= 0 && tuv.z >= 0 && tuv.y + tuv.z <= 1);
}

void
main()
{
	uint invocation_index = gl_GlobalInvocationID.y*gl_NumWorkGroups.x*gl_WorkGroupSize.x + gl_GlobalInvocationID.x;
	uint seed = (invocation_index + frame_index*187272781)*178525871;
	pcg32_seed(pcg_state, seed, invocation_index);

	float screen_width = 1;
	float screen_height = 9.0/16.0;
	float near_plane = 1/(2*tan(fov/2));

	float screen_dx = screen_width/(gl_NumWorkGroups.x*gl_WorkGroupSize.x);
	float screen_dy = screen_height/(gl_NumWorkGroups.y*gl_WorkGroupSize.y);
	vec3 ray = vec3(-screen_width/2 + screen_dx*gl_GlobalInvocationID.x, -screen_height/2 + screen_dy*gl_GlobalInvocationID.y, near_plane);
	ray += vec3(Random01()*screen_dx, Random01()*screen_dy, 0);
	ray = normalize(ray);

	int closest_hit_id = -1;
	vec3 closest_hit_tuv = vec3(1000000, 0, 0);
	for (int i = 0; i < 1000; ++i)
	{
		Triangle t = tris[i];
		vec4 alpha = t.alpha;
		vec4 beta = t.beta;

		vec3 p0 = alpha.xyz;
		vec3 p1 = beta.xyz;
		vec3 p2 = vec3(alpha.w, beta.w, tris[i].gamma.x);

		vec3 tuv;
		if (MollerTrumbore(vec3(0), ray, p0, p1, p2, false, tuv))
		{
			if (tuv.x < closest_hit_tuv.x)
			{
				closest_hit_id  = i;
				closest_hit_tuv = tuv;
			}
		}
	}

	if (closest_hit_id == -1) imageStore(backbuffer, ivec2(gl_GlobalInvocationID.xy), vec4(0, 0, 0, 1));
	else                      imageStore(backbuffer, ivec2(gl_GlobalInvocationID.xy), vec4(vec2(closest_hit_tuv.yz), 0, 1));
}
