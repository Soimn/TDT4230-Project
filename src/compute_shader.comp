#version 450 core

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct Triangle_Data
{
	vec4 p0_p2x;
	vec4 p1_p2y;
	vec4 p2z;
};

struct Triangle_Material_Data
{
	vec4 n0_n2x;
	vec4 n1_n2y;
	vec4 n2z_mat;
};

struct Bounding_Sphere
{
	vec4 p_r;
};

struct Light
{
  vec4 p0_nx;
  vec4 p1_ny;
  vec4 p2_nz;
  vec4 area_id_mat;
};

#define MaterialKind_Diffuse    0
#define MaterialKind_Reflective 1
#define MaterialKind_Refractive 2
#define MaterialKind_Light      3

struct Material
{
	vec4 color;
	uint kind;
};

layout(rgba32f, binding = 0) restrict writeonly uniform image2D backbuffer;
layout(rgba32f, binding = 1) restrict uniform image2D accumulated_frames_buffer;
layout(std140,  binding = 2) restrict readonly buffer triangle_data        { Triangle_Data tri_data[];              };
layout(std140,  binding = 3) restrict readonly buffer triangle_mat_data    { Triangle_Material_Data tri_mat_data[]; };
layout(std140,  binding = 4) restrict readonly buffer bounding_sphere_data { Bounding_Sphere bounding_spheres[];    };
layout(std140,  binding = 5) restrict readonly buffer material_data        { Material materials[];                  };
layout(std140,  binding = 6) restrict readonly buffer light_data           { Light lights[];                        };

layout(location = 0) uniform uint frame_index;
layout(location = 1) uniform vec2 backbuffer_dim;

#define PI32  3.1415926535
#define TAU32 6.2831853071
#define PI32_ON_2 1.5707963267

#define AIR_IOR 1.000293

struct pcg32_state
{
	uint state;
	uint increment;
};

void pcg32_seed(inout pcg32_state pcg_state, uint seed, uint increment);
uint pcg32_next(inout pcg32_state pcg_state);

pcg32_state pcg_state;

float
Random01()
{
	return pcg32_next(pcg_state) * 2.3283064365386962890625e-10;
}

// NOTE: pdf = 1/4pi
vec3
RandomDir()
{
	float x_1 = Random01();
	float x_2 = Random01();

	float phi = TAU32*x_1;
	//float theta = PI32*x_2;
	//float theta = acos(1 - 2*x_2); // NOTE: inverse transform sampling: https://corysimon.github.io/articles/uniformdistn-on-sphere/
	// NOTE: Changed to eq 6-8 from: https://mathworld.wolfram.com/SpherePointPicking.html
	float u = x_2*2 - 1;
	float eta = sqrt(1 - u*u);
	return vec3(cos(phi)*eta, sin(phi)*eta, u);
}

// NOTE: pdf = 1/2pi
vec3
RandomDirInHemi(vec3 plane_normal)
{
	vec3 dir = RandomDir();
	return (dot(dir, plane_normal) < 0 ? -dir : dir);
}

// NOTE: pdf = cos theta_i / pi
vec3
CosineWeightedRandomDirInHemi(vec3 plane_normal)
{
  return normalize(plane_normal + RandomDir());
}

struct Hit_Data
{
	int id;
	int material_id;
	vec3 point;
	vec3 normal;
};

Hit_Data
CastRay(vec3 origin, vec3 ray, bool invert_faces)
{
	Hit_Data result;
	result.id        = -1;
  vec3 closest_tuv = vec3(1e9, 0, 0);

	for (int i = 0; i < bounding_spheres.length(); ++i)
	{
		vec4 pr = bounding_spheres[i].p_r;
		vec3 p  = pr.xyz;
		float r = pr.w;

		vec3 op = p - origin;
		float b = dot(op, ray);

		float discriminant = b*b - dot(op, op) + r*r;
		if (discriminant < 0) continue;

		vec3 p0 = tri_data[i].p0_p2x.xyz;
		vec3 p1 = tri_data[i].p1_p2y.xyz;
		vec3 p2 = vec3(tri_data[i].p0_p2x.w, tri_data[i].p1_p2y.w, tri_data[i].p2z.x);

    // Derived from math presented in the paper "Fast, Minimum Storage Ray/Triangle Intersection" by MÃ¶ller and Trumbore.
    // https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf
    vec3 D       = ray;
    vec3 T       = origin - p0;
    vec3 E_1     = p1 - p0;
    vec3 E_2     = p2 - p0;
    vec3 E_1xE_2 = cross(E_1, E_2);
    vec3 DxT     = cross(D, T);

    float denominator = dot(D, -E_1xE_2);

    vec3 tuv = vec3(dot(T, E_1xE_2), dot(-E_2, DxT), dot(E_1, DxT)) / denominator;

    bool hit_plane = (invert_faces ? denominator < 0 : denominator > 0);
    if ((tuv.x > 0 && tuv.x < closest_tuv.x) && hit_plane && tuv.y >= 0 && tuv.z >= 0 && tuv.y + tuv.z <= 1)
    {
			result.id   = i;
			closest_tuv = tuv;
    }
	}

	if (result.id != -1)
	{
		int i = result.id;

		vec3 n0 = tri_mat_data[i].n0_n2x.xyz;
		vec3 n1 = tri_mat_data[i].n1_n2y.xyz;
		vec3 n2 = vec3(tri_mat_data[i].n0_n2x.w, tri_mat_data[i].n1_n2y.w, tri_mat_data[i].n2z_mat.x);

		float lambda_1 = closest_tuv.y;
		float lambda_2 = closest_tuv.z;
		float lambda_3 = 1 - lambda_1 - lambda_2;

		result.point       = origin + closest_tuv.x*ray;
		result.normal      = lambda_3*n0 + lambda_1*n1 + lambda_2*n2;
		result.material_id = int(tri_mat_data[i].n2z_mat.y);

		if (invert_faces) result.normal = -result.normal;
	}

	return result;
}

void
main()
{
	uint invocation_index = gl_GlobalInvocationID.y*gl_NumWorkGroups.x*gl_WorkGroupSize.x + gl_GlobalInvocationID.x;
	uint seed = (invocation_index + frame_index*187272781)*178525871;
	pcg32_seed(pcg_state, seed, invocation_index);

	vec3 origin           = vec3(0);
	float near_plane      = backbuffer_dim.x/2;
	float gaussian_radius = 2;
	vec3 ray = vec3(backbuffer_dim.x/2 - gl_GlobalInvocationID.x, -backbuffer_dim.y/2 + gl_GlobalInvocationID.y, near_plane);
	ray += gaussian_radius*(2*vec3(Random01() + Random01() + Random01(), Random01() + Random01() + Random01(), 0)/3 - vec3(1));
	ray = normalize(ray);

  vec3 color      = vec3(0);
  vec3 multiplier = vec3(1);

	for (uint bounce = 0; bounce < 6; ++bounce)
	{
		Hit_Data hit = CastRay(origin, ray, false);
		if (hit.id == -1) break;
		else
		{
			Material hit_material = materials[hit.material_id];

			if (hit_material.kind == MaterialKind_Light)
			{
				color += multiplier*hit_material.color.xyz*hit_material.color.w;
				break;
			}
			else
			{
				multiplier *= hit_material.color.xyz;

				origin = hit.point + hit.normal*0.001;
				ray    = CosineWeightedRandomDirInHemi(hit.normal);
			}
		}
	}

	vec4 accumulated_value = imageLoad(accumulated_frames_buffer, ivec2(gl_GlobalInvocationID.xy));
	accumulated_value.xyz += color;
	imageStore(accumulated_frames_buffer, ivec2(gl_GlobalInvocationID.xy), accumulated_value);
	imageStore(backbuffer, ivec2(gl_GlobalInvocationID.xy), vec4(accumulated_value.xyz/(frame_index+1), 1));
}
