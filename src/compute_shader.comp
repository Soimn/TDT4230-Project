#version 450 core

struct Triangle_Data
{
	vec4 alpha;
	vec4 beta;
	vec4 gamma;
};

struct Triangle_Material_Data
{
	vec4 n0uv0x;
	vec4 n1uv0y;
	vec4 n2mat;
	vec4 uv12;
};

struct Bounding_Sphere
{
	vec4 pr;
};

#define MaterialKind_Diffuse    0
#define MaterialKind_Reflective 1
#define MaterialKind_Refractive 2
#define MaterialKind_Light      3

struct Material
{
	vec4 color;
	uint kind;
};

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
layout(rgba32f, binding = 0) restrict writeonly uniform image2D backbuffer;
layout(rgba32f, binding = 1) restrict uniform image2D accumulated_frames_buffer;
layout(std140, binding = 2) restrict readonly buffer triangle_data { Triangle_Data tri_data[]; };
layout(std140, binding = 3) restrict readonly buffer triangle_mat_data { Triangle_Material_Data tri_mat_data[]; };
layout(std140, binding = 4) restrict readonly buffer bounding_sphere_data { Bounding_Sphere bounding_spheres[]; };

layout(std140, binding = 6) restrict readonly buffer material_data { Material materials[]; };
layout(std140, binding = 7) restrict readonly buffer light_index_data { int lights[]; };

layout(location = 0) uniform uint frame_index;
layout(location = 1) uniform float fov;
layout(location = 2) uniform vec2 backbuffer_dim;

#define PI32  3.1415926535
#define TAU32 6.2831853071
#define PI32_ON_2 1.5707963267

#define AIR_IOR 1.000293

struct pcg32_state
{
	uint state;
	uint increment;
};

void pcg32_seed(inout pcg32_state pcg_state, uint seed, uint increment);
uint pcg32_next(inout pcg32_state pcg_state);

pcg32_state pcg_state;

float
Random01()
{
	return pcg32_next(pcg_state) * 2.3283064365386962890625e-10;
}

// NOTE: pdf = 1/4pi
vec3
RandomDir()
{
	float x_1 = Random01();
	float x_2 = Random01();

	float phi = TAU32*x_1;
	//float theta = PI32*x_2;
	//float theta = acos(1 - 2*x_2); // NOTE: inverse transform sampling: https://corysimon.github.io/articles/uniformdistn-on-sphere/
	// NOTE: Changed to eq 6-8 from: https://mathworld.wolfram.com/SpherePointPicking.html
	float u = x_2*2 - 1;
	float eta = sqrt(1 - u*u);
	return vec3(cos(phi)*eta, sin(phi)*eta, u);
}

// NOTE: pdf = 1/2pi
vec3
RandomDirInHemi(vec3 plane_normal)
{
	vec3 dir = RandomDir();
	return (dot(dir, plane_normal) < 0 ? -dir : dir);
}

// Derived from math presented in the paper "Fast, Minimum Storage Ray/Triangle Intersection" by MÃ¶ller and Trumbore.
// https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf
bool
MollerTrumbore(vec3 origin, vec3 ray, vec3 p0, vec3 p1, vec3 p2, bool invert_faces, out vec3 tuv)
{
	vec3 D = ray;
	vec3 T = origin - p0;
	vec3 E_1 = p1 - p0;
	vec3 E_2 = p2 - p0;
	vec3 E_1xE_2 = cross(E_1, E_2);
	vec3 DxT     = cross(D, T);

	float denominator = dot(D, -E_1xE_2);

	tuv = vec3(dot(T, E_1xE_2), dot(-E_2, DxT), dot(E_1, DxT)) / denominator;

	bool hit_plane = (invert_faces ? denominator < 0 : denominator > 0);
	return (hit_plane && tuv.x > 0 && tuv.y >= 0 && tuv.z >= 0 && tuv.y + tuv.z <= 1);
}

struct Hit_Data
{
	int id;
	int material_id;
	vec3 point;
	vec3 normal;
	vec3 u;
	vec2 uv;
	vec3 tuv;
};

Hit_Data
CastRay(vec3 origin, vec3 ray, bool invert_faces)
{
	Hit_Data result;
	result.id     = -1;
	result.tuv.x  = 1e9;

	for (int i = 0; i < bounding_spheres.length(); ++i)
	{
		vec4 pr = bounding_spheres[i].pr;
		vec3 p  = pr.xyz;
		float r = pr.w;

		vec3 op = p - origin;
		float b = dot(op, ray);

		float discriminant = b*b - dot(op, op) + r*r;
		if (discriminant < 0) continue;

		vec3 p0 = tri_data[i].alpha.xyz;
		vec3 p1 = tri_data[i].beta.xyz;
		vec3 p2 = vec3(tri_data[i].alpha.w, tri_data[i].beta.w, tri_data[i].gamma.x);

		vec3 tuv = vec3(0);
		if (MollerTrumbore(origin, ray, p0, p1, p2, invert_faces, tuv) && tuv.x < result.tuv.x)
		{
			result.id  = i;
			result.tuv = tuv;
		}
	}

	if (result.id != -1)
	{
		int i = result.id;

		vec2 uv0 = vec2(tri_mat_data[i].n0uv0x.w, tri_mat_data[i].n1uv0y.w);
		vec2 uv1 = tri_mat_data[i].uv12.xy;
		vec2 uv2 = tri_mat_data[i].uv12.zw;

		vec3 n0 = tri_mat_data[i].n0uv0x.xyz;
		vec3 n1 = tri_mat_data[i].n1uv0y.xyz;
		vec3 n2 = tri_mat_data[i].n2mat.xyz;

		float lambda_1 = result.tuv.y;
		float lambda_2 = result.tuv.z;
		float lambda_3 = 1 - lambda_1 - lambda_2;

		result.point       = origin + result.tuv.x*ray;
		result.uv          = lambda_3*uv0 + lambda_1*uv1 + lambda_2*uv2;
		result.u           = normalize(tri_data[i].beta.xyz - tri_data[i].alpha.xyz);
		result.normal      = lambda_3*n0 + lambda_1*n1 + lambda_2*n2;
		result.material_id = int(tri_mat_data[i].n2mat.w);

		if (invert_faces) result.normal = -result.normal;
	}

	return result;
}

void
main()
{
	uint invocation_index = gl_GlobalInvocationID.y*gl_NumWorkGroups.x*gl_WorkGroupSize.x + gl_GlobalInvocationID.x;
	uint seed = (invocation_index + frame_index*187272781)*178525871;
	pcg32_seed(pcg_state, seed, invocation_index);

	float near_plane = backbuffer_dim.x/(2*tan(fov/2));

	vec3 ray = vec3(backbuffer_dim.x/2 - gl_GlobalInvocationID.x, -backbuffer_dim.y/2 + gl_GlobalInvocationID.y, near_plane);
	ray += vec3(-Random01(), Random01(), 0);
	ray = normalize(ray);

	vec3 origin     = vec3(0);
	vec3 color      = vec3(0);
	vec3 multiplier = vec3(1);
	bool is_trans   = false;
	for (uint bounce_index = 0; bounce_index < 10; ++bounce_index)
	{
		Hit_Data hit_data = CastRay(origin, ray, is_trans);
		vec3 new_origin = hit_data.point + hit_data.normal*0.0001;
		
		if (hit_data.id == -1) break;
		else
		{
			Material material = materials[int(hit_data.material_id)];

			if (material.kind == MaterialKind_Light)
			{
				if (bounce_index == 0) color += multiplier*material.color.xyz;
				//color += multiplier*material.color.xyz;
			}
			else if (material.kind == MaterialKind_Diffuse)
			{
				int light_id = lights[clamp(int(Random01()*lights.length()), 0, lights.length()-1)];
				vec3 light_p0 = tri_data[light_id].alpha.xyz;
				vec3 light_p1 = tri_data[light_id].beta.xyz;
				vec3 light_p2 = vec3(tri_data[light_id].alpha.w, tri_data[light_id].beta.w, tri_data[light_id].gamma.x);

				float light_l1 = Random01();
				float light_l2 = Random01();
				vec3 light_p = light_p0*light_l1 + light_p1*light_l2 + light_p2*(1-light_l1-light_l2);

				vec3 to_light   = light_p - new_origin;
				vec3 to_light_n = normalize(to_light);

				Hit_Data light_hit_data = CastRay(new_origin, to_light_n, false);
				if (light_hit_data.id == light_id)
				{
					Material light_material = materials[int(tri_mat_data[light_id].n2mat.w)];
					vec3 l_i = light_material.color.xyz;

					float cos_theta_i = dot(to_light_n, hit_data.normal);
					float cos_theta_o = dot(-to_light_n, light_hit_data.normal);
					float light_area  = length(cross(light_p1-light_p0, light_p2-light_p0));
					color += multiplier*l_i*cos_theta_i*((light_area*cos_theta_o)/dot(to_light, to_light));
				}
				break;

				vec3 new_ray = normalize(hit_data.normal + RandomDir());

				multiplier *= material.color.xyz;

				origin = new_origin;
				ray    = new_ray;
			}
			else if (material.kind == MaterialKind_Reflective)
			{
				vec3 new_ray = reflect(ray, hit_data.normal);

				origin = new_origin;
				ray    = new_ray;
			}
			else
			{
				// TODO: total internal reflection, absorbtion, dispersion
				float ior = material.color.w;
				
				float n1 = AIR_IOR;
				float n2 = ior;
				if (is_trans)
				{
					n1 = ior;
					n2 = AIR_IOR;
				}

				float r = (n1 - n2)/(n1 + n2);
				r *= r;

				if (Random01() <= r)
				{
					vec3 new_ray = reflect(ray, hit_data.normal);

					origin = new_origin;
					ray    = new_ray;
				}
				else
				{
					vec3 new_ray = refract(ray, hit_data.normal, n1/n2);

					is_trans = !is_trans;

					origin = new_origin;
					ray    = new_ray;
				}
			}
		}
	}

	vec4 accumulated_value = imageLoad(accumulated_frames_buffer, ivec2(gl_GlobalInvocationID.xy));
	accumulated_value.xyz += color;
	imageStore(accumulated_frames_buffer, ivec2(gl_GlobalInvocationID.xy), accumulated_value);
	imageStore(backbuffer, ivec2(gl_GlobalInvocationID.xy), vec4(accumulated_value.xyz/(frame_index+1), 1));
}
